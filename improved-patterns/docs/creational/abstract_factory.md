# 抽象工厂模式 (Abstract Factory Pattern)

## 意图

提供一个创建一系列相关或相互依赖对象的接口,而无需指定它们具体的类。

## 问题

当需要创建一组相关的对象,且希望确保它们来自同一产品族时:
- 系统需要独立于产品的创建和组合
- 需要配置多个产品系列之一
- 希望强调产品对象的设计以便联合使用
- 只想显示接口而不是实现

## 解决方案

抽象工厂模式定义了一个抽象工厂接口,用于创建一组相关的产品对象。每个具体工厂实现这个接口,创建特定产品族的所有产品。

## 适用场景

1. **系统需要独立于产品创建**
   - 例如:跨平台UI库需要为不同操作系统创建一致的组件

2. **系统需要由多个产品系列中的一个来配置**
   - 例如:主题系统(深色主题vs浅色主题)

3. **强调一系列产品对象的联合使用**
   - 例如:GUI组件必须风格一致

4. **提供产品类库,只显示接口**
   - 例如:数据库适配器,为不同数据库提供统一接口

## 结构

```
        Client
           |
           ↓
    AbstractFactory
    +createProductA()
    +createProductB()
           △
           |
    ┌──────┴──────┐
    |             |
ConcreteFactory1  ConcreteFactory2
```

## Python 实现

参见代码: `patterns/creational/abstract_factory.py`

### 关键点
- 定义抽象产品接口
- 每个具体工厂创建一个产品族
- 客户端只与抽象接口交互

## 优点

✓ **产品族一致性**: 确保同一工厂创建的对象属于同一产品族
✓ **隔离具体类**: 客户端不知道具体产品类
✓ **易于交换产品族**: 只需切换工厂即可
✓ **开闭原则**: 添加新产品族无需修改客户端代码

## 缺点

✗ **难以支持新产品**: 添加新产品类型需要修改所有工厂
✗ **增加复杂度**: 需要创建大量接口和类
✗ **不够灵活**: 产品族结构固定

## 最佳实践

### Python 特定建议
- 使用 ABC 模块定义抽象工厂和产品
- 考虑使用工厂注册表管理多个工厂
- 可以与依赖注入结合使用

### 通用建议
- 只在确实需要产品族时使用
- 考虑是否可以简化为工厂方法
- 文档化产品族的约束和依赖

## 真实应用案例

1. **GUI 工具包**: Qt/Gtk 为不同平台创建一致的组件
2. **数据库适配器**: SQLAlchemy 为不同数据库提供统一接口
3. **主题系统**: 应用程序的深色/浅色主题
4. **文档格式**: 创建不同格式的文档元素(PDF/HTML)

## 相关模式

- **工厂模式**: 抽象工厂使用工厂方法创建产品
- **单例模式**: 具体工厂通常是单例
- **原型模式**: 工厂可以使用原型克隆产品

## 对比

| 特性 | 工厂模式 | 抽象工厂模式 |
|-----|---------|------------|
| 创建对象 | 单一产品 | 产品族 |
| 复杂度 | 简单 | 较复杂 |
| 扩展性 | 易于添加产品 | 难以添加新产品类型 |
| 适用场景 | 一种类型的对象 | 一组相关对象 |

## 进一步学习

- 运行示例: `patterns run abstract_factory`
- 查看代码: `patterns/creational/abstract_factory.py`
- 运行测试: `patterns test abstract_factory`
