# 建造者模式 (Builder Pattern)

## 意图

将一个复杂对象的构建与它的表示分离,使得同样的构建过程可以创建不同的表示。

## 问题

创建复杂对象时面临的问题:
- 对象有很多可选参数,构造函数参数过多
- 对象的创建需要多个步骤
- 需要用不同的配置创建同类对象
- 构造逻辑复杂,难以维护

## 解决方案

建造者模式将对象构建过程封装在独立的建造者类中:
1. 定义通用的构建步骤
2. 让具体建造者实现这些步骤
3. 使用指挥者控制构建顺序
4. 支持链式调用提高可读性

## 适用场景

1. **对象有复杂内部结构**
   - 例如:构建复杂的HTML文档或SQL查询

2. **需要生成的对象内部属性相互依赖**
   - 例如:配置对象的某些属性依赖其他属性

3. **对象创建过程独立于创建它的类**
   - 例如:使用同样的步骤构建不同类型的对象

4. **隔离复杂对象的创建和使用**
   - 例如:游戏中创建不同类型的角色

## 结构

```
     Director
        |
        ↓
   Builder (抽象)
   +buildPartA()
   +buildPartB()
   +getResult()
        △
        |
 ConcreteBuilder
```

## Python 实现

参见代码: `patterns/creational/builder.py`

### 关键点
- 使用方法链 (return self) 支持链式调用
- 可选使用指挥者控制构建顺序
- 每个建造者维护自己的产品实例

### 代码示例

```python
computer = (ComputerBuilder()
            .build_cpu()
            .build_ram()
            .build_storage()
            .get_computer())
```

## 优点

✓ **分离构建和表示**: 相同构建过程创建不同对象
✓ **精细控制**: 可以逐步构建对象
✓ **代码可读性**: 链式调用清晰易懂
✓ **避免伸缩构造函数**: 解决参数过多问题

## 缺点

✗ **增加代码量**: 需要创建多个类
✗ **产品变化影响建造者**: 产品结构变化需修改建造者
✗ **可能过度设计**: 简单对象不需要使用

## 最佳实践

### Python 特定建议
- 使用 `return self` 实现链式调用
- 考虑使用 dataclass 简化产品类
- 可选步骤应有默认值

### 通用建议
- 只对复杂对象使用建造者模式
- 保持建造步骤的独立性
- 提供合理的默认值

## 真实应用案例

1. **StringBuilder**: Java 的字符串构建器
2. **QueryBuilder**: ORM 框架的查询构建器
3. **pytest.fixture**: 构建测试数据
4. **HTML构建器**: 生成HTML文档

## 相关模式

- **抽象工厂**: 抽象工厂创建产品族,建造者逐步构建复杂产品
- **组合模式**: 建造者经常用来构建组合对象
- **单例模式**: 建造者可以是单例

## 变体

### Fluent Builder
使用链式调用的建造者:
```python
builder.step1().step2().step3().build()
```

### 嵌套建造者
产品包含复杂的嵌套对象时使用。

## 进一步学习

- 运行示例: `patterns run builder`
- 查看代码: `patterns/creational/builder.py`
- 运行测试: `patterns test builder`
