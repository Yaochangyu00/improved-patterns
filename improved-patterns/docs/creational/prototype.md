# 原型模式 (Prototype Pattern)

## 意图

用原型实例指定创建对象的种类,并且通过复制这些原型创建新的对象。

## 问题

创建对象时面临的问题:
- 直接创建对象成本很高
- 需要在运行时创建对象,但不知道具体类
- 需要创建大量相似的对象
- 想避免与具体类耦合

## 解决方案

原型模式通过克隆现有对象来创建新对象:
1. 定义克隆方法
2. 让原型对象负责克隆自己
3. 使用深克隆或浅克隆
4. 可以使用原型注册表管理原型

## 适用场景

1. **创建对象成本很高**
   - 例如:从数据库加载大量数据的对象

2. **运行时创建对象但不知道具体类**
   - 例如:插件系统中动态创建对象

3. **避免创建工厂类层次**
   - 例如:用原型代替复杂的工厂体系

4. **通过克隆创建更方便**
   - 例如:游戏中复制敌人对象

## 结构

```
    Client
       |
       ↓
   Prototype
   +clone()
       △
       |
ConcretePrototype
```

## Python 实现

参见代码: `patterns/creational/prototype.py`

### 关键点
- 使用 `copy` 模块的 `copy()` 和 `deepcopy()`
- 理解浅克隆和深克隆的区别
- 可以实现 `__copy__` 和 `__deepcopy__` 自定义克隆行为

### 代码示例

```python
import copy

# 浅克隆 - 共享嵌套对象引用
shallow = copy.copy(original)

# 深克隆 - 完全独立的副本
deep = copy.deepcopy(original)
```

## 优点

✓ **避免重复初始化**: 直接克隆减少开销
✓ **动态配置**: 运行时动态添加/删除原型
✓ **减少子类数量**: 不需要创建与产品层次平行的工厂类
✓ **用不同值创建新对象**: 克隆后修改属性

## 缺点

✗ **克隆包含循环引用的对象困难**
✗ **深克隆代价高**: 复杂对象的深克隆可能很慢
✗ **需要实现克隆方法**: 现有类可能需要修改

## 最佳实践

### Python 特定建议
- 使用 `copy.copy()` 和 `copy.deepcopy()`
- 注意可变对象(list, dict)的浅克隆问题
- 使用原型注册表管理预定义原型

### 通用建议
- 明确何时需要深克隆vs浅克隆
- 为包含引用类型的对象使用深克隆
- 文档化克隆行为

## 浅克隆 vs 深克隆

| 类型 | 原始值 | 嵌套对象 | 使用场景 |
|-----|-------|---------|---------|
| 浅克隆 | 复制 | 共享引用 | 简单对象,无嵌套 |
| 深克隆 | 复制 | 递归复制 | 复杂对象,有嵌套 |

## 真实应用案例

1. **图形编辑器**: 复制粘贴图形对象
2. **游戏开发**: 克隆敌人、道具
3. **配置管理**: 基于模板创建配置
4. **数据库记录**: 复制记录创建新版本

## 相关模式

- **工厂方法**: 可以用原型替代工厂方法
- **抽象工厂**: 可以用原型存储产品族
- **备忘录模式**: 保存对象状态

## 注意事项

1. **循环引用**: 深克隆需要处理循环引用
2. **不可克隆对象**: 文件句柄、网络连接等不能克隆
3. **修改共享状态**: 浅克隆后修改嵌套对象会影响原型

## 进一步学习

- 运行示例: `patterns run prototype`
- 查看代码: `patterns/creational/prototype.py`
- 运行测试: `patterns test prototype`
