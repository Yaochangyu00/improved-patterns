# 设计模式索引

欢迎使用改进的 Python 设计模式学习项目！本索引列出了所有可用的设计模式及其文档。

## 快速导航

- [创建型模式](#创建型模式)
- [结构型模式](#结构型模式)
- [行为型模式](#行为型模式)
- [其他模式](#其他模式)

---

## 创建型模式

创建型模式关注对象创建机制,通过控制创建过程来解决问题。

| 模式 | 描述 | 文档 |
|-----|------|------|
| **单例模式**<br>(Singleton) | 确保一个类只有一个实例,并提供全局访问点 | [singleton.md](creational/singleton.md) |
| **工厂模式**<br>(Factory) | 定义创建对象的接口,让子类决定实例化哪个类 | [factory.md](creational/factory.md) |
| 抽象工厂模式<br>(Abstract Factory) | 创建相关或依赖对象族,无需指定具体类 | *待实现* |
| 建造者模式<br>(Builder) | 分步骤构建复杂对象,使构造过程和表示分离 | *待实现* |
| 原型模式<br>(Prototype) | 通过复制现有对象来创建新对象 | *待实现* |
| 对象池模式<br>(Object Pool) | 预先创建对象池,复用对象以提高性能 | *待实现* |
| 惰性求值模式<br>(Lazy Evaluation) | 延迟计算直到真正需要结果时 | *待实现* |

---

## 结构型模式

结构型模式关注类和对象的组合,通过组合来获得新功能。

| 模式 | 描述 | 文档 |
|-----|------|------|
| 适配器模式<br>(Adapter) | 将一个类的接口转换成客户端期望的另一个接口 | *待实现* |
| 桥接模式<br>(Bridge) | 将抽象与实现分离,使它们可以独立变化 | *待实现* |
| 组合模式<br>(Composite) | 将对象组合成树形结构以表示"部分-整体"层次 | *待实现* |
| 装饰器模式<br>(Decorator) | 动态地给对象添加额外的职责 | *待实现* |
| 外观模式<br>(Facade) | 为子系统提供统一的高层接口 | *待实现* |
| 享元模式<br>(Flyweight) | 运用共享技术有效支持大量细粒度对象 | *待实现* |
| 代理模式<br>(Proxy) | 为其他对象提供一种代理以控制对这个对象的访问 | *待实现* |
| MVC 模式<br>(MVC) | 将应用分为模型、视图和控制器三部分 | *待实现* |
| 三层模式<br>(3-Tier) | 将应用分为表示层、业务逻辑层和数据访问层 | *待实现* |

---

## 行为型模式

行为型模式关注对象之间的通信,明确对象之间的职责分配。

| 模式 | 描述 | 文档 |
|-----|------|------|
| **观察者模式**<br>(Observer) | 定义对象间一对多依赖,当对象状态改变时通知所有依赖者 | [observer.md](behavioral/observer.md) |
| 责任链模式<br>(Chain of Responsibility) | 将请求沿着处理者链传递,直到有对象处理它 | *待实现* |
| 命令模式<br>(Command) | 将请求封装为对象,从而使请求参数化 | *待实现* |
| 迭代器模式<br>(Iterator) | 提供一种顺序访问聚合对象元素的方法 | *待实现* |
| 中介者模式<br>(Mediator) | 用一个中介对象封装一系列对象交互 | *待实现* |
| 备忘录模式<br>(Memento) | 在不破坏封装的前提下捕获对象的内部状态 | *待实现* |
| 状态模式<br>(State) | 允许对象在内部状态改变时改变其行为 | *待实现* |
| 策略模式<br>(Strategy) | 定义算法族,分别封装,使它们可以互相替换 | *待实现* |
| 模板方法模式<br>(Template Method) | 定义算法骨架,将某些步骤延迟到子类 | *待实现* |
| 访问者模式<br>(Visitor) | 在不改变元素类的前提下定义作用于元素的新操作 | *待实现* |
| 发布-订阅模式<br>(Publish-Subscribe) | 通过事件通道解耦发布者和订阅者 | *待实现* |

---

## 其他模式

其他有用的设计模式和编程技巧。

| 模式 | 描述 | 文档 |
|-----|------|------|
| 依赖注入模式<br>(Dependency Injection) | 将依赖关系注入到对象中,而非对象自己创建 | *待实现* |
| 黑板模式<br>(Blackboard) | 多个专门系统通过共享的黑板协作解决问题 | *待实现* |

---

## 使用指南

### 查看文档

```bash
# 使用 CLI 查看文档
patterns docs singleton

# 或直接查看 Markdown 文件
cat docs/creational/singleton.md
```

### 运行示例

```bash
# 运行模式示例
patterns run singleton
patterns run factory
patterns run observer
```

### 运行测试

```bash
# 运行特定模式的测试
patterns test singleton

# 运行所有测试
patterns test
```

---

## 学习路径

### 初学者

1. **从创建型模式开始**: 单例 → 工厂 → 建造者
2. **学习结构型模式**: 装饰器 → 适配器 → 代理
3. **掌握行为型模式**: 观察者 → 策略 → 命令

### 进阶

- 对比相似模式:工厂 vs 抽象工厂
- 研究模式组合:策略 + 工厂
- 了解反模式:避免常见错误

---

## 图例

- **粗体**: 已实现的模式(MVP)
- *待实现*: 计划实现的模式

---

## 贡献

欢迎贡献新的设计模式实现！请查看 README.md 了解贡献指南。

---

**最后更新**: 2025-11-20
**版本**: 1.0.0
